package forSlick2D;
import java.text.DecimalFormat;import java.util.Vector;
import org.newdawn.slick.Color;import org.newdawn.slick.GameContainer;import org.newdawn.slick.Graphics;import org.newdawn.slick.Image;import org.newdawn.slick.Input;import org.newdawn.slick.SlickException;import org.newdawn.slick.geom.Point;import org.newdawn.slick.geom.Rectangle;import org.newdawn.slick.geom.Shape;import org.newdawn.slick.geom.Transform;import org.newdawn.slick.state.BasicGameState;import org.newdawn.slick.state.StateBasedGame;
//BasicScene은 Slick2D의 BasicGameState를 기본으로 확장한 클래스public class BasicScene extends BasicGameState {
 //BasicGameState 처리를 위한 변수 //game은 Slick2D 엔진이 최초 수행하는 StateBasedGame을, //gc는 Slick2D 엔진이 관리하는 게임 컨테이너(게임이 실행되는 창 크기,프레임레이트,게임의 실행 등)정보 protected StateBasedGame game; protected GameContainer gc; protected int id = -1;
 protected boolean isPause; protected boolean isDebug;
 protected boolean fullScreen;//전체화면 토글 스위치  //GameObject 처리를 위한 변수 Vector<GameObject> node;//처리하기 위한 모든 GameObject Vector<GameObject> deleteList;//삭제 처리를 위한 리스트
 public BasicScene() {  // TODO Auto-generated constructor stub    node = new Vector<GameObject>();  node.clear();    deleteList = new Vector<GameObject>();  deleteList.clear();    isPause = false;  isDebug = false;   } public BasicScene(int id) {  // TODO Auto-generated constructor stub
  this();  this.id = id; }
 @Override public void init(GameContainer arg0, StateBasedGame arg1)   throws SlickException {  // TODO Auto-generated method stub
  game = arg1;  gc = arg0;   }
 @Override public void render(GameContainer arg0, StateBasedGame arg1, Graphics arg2)   throws SlickException {  // TODO Auto-generated method stub    //출력 순서를 정리한다  for(int i=0;i<node.size();i++){      GameObject temp1 = (GameObject)node.get(i);      int _zorder = 0;      for(int j=0;j<node.size();j++){
    if( i==j ) continue;        GameObject temp2 = (GameObject)node.get(j);    if(temp1.zorder > temp2.zorder)     _zorder++;        //자신보다 zorder가 작은 오브젝트가 몇 개나 있나 센다.    //자신의 zorder가 가장 크다면 가장 먼저 그려지는 오브젝트가 된다.    //임의의 값을 설정할 수 있는 zorder와 달리, _zorder는 오브젝트 전체의 갯수 이상이 될 수 없다   }      temp1._zorder = _zorder;  }
  //정리된 출력 순서대로 출력한다  for(int i=0;i<node.size();i++){
   for(int j=0;j<node.size();j++){        GameObject temp = (GameObject)node.get(j);    if( temp._zorder == i)      temp.render(arg0, arg1, arg2);        //이 루프가 상당히 비효율적이지만, 하나만 render하고 브레이크하면    //zorder가 같은 오브젝트가 있을 경우 출력에서 누락된다   }  }    if(isDebug){      arg2.setColor(Color.white);   arg2.drawString("GameObjects node = " + getNumOfChildren(), 10, 40);  } }
 @Override public void update(GameContainer arg0, StateBasedGame arg1, int arg2)   throws SlickException {  // TODO Auto-generated method stub    //풀스크린 on/off  //※풀스크린 전환은 update 이외의 다른 곳에서 하면 오류가 발생한다  if(fullScreen!=arg0.isFullscreen())   arg0.setFullscreen(fullScreen);
  if(isPause)   return;    //삭제리스트가 있으면 한꺼번에 삭제한다.  //여기 이외의 장소에서는 직접 node에서 삭제되는 일은 없다.  //내부적으로 render는 update 이후에 불린다.  if(deleteList.size()>0){   node.removeAll(deleteList);   deleteList.clear();  }
  //현재 벡터상에 있는 오브젝트의 update를 호출한다  for(int i=0;i<node.size();i++){   GameObject temp = (GameObject)node.get(i);   temp.update();  }   }
 @Override public int getID() {  // TODO Auto-generated method stub    return id; }
 @Override public void enter(GameContainer container, StateBasedGame game)   throws SlickException {  // TODO Auto-generated method stub  super.enter(container, game);
  fullScreen = container.isFullscreen();  }  @Override public void leave(GameContainer container, StateBasedGame game)   throws SlickException {  // TODO Auto-generated method stub  super.leave(container, game);  _removeAllChildren(); }  @Override public void keyReleased(int key, char c) {  // TODO Auto-generated method stub  super.keyReleased(key, c);
  switch (key) {     case Input.KEY_1:   this.setPause(!this.isPaused());   break;  case Input.KEY_2://디버그 모드 온오프   this.setDebug(!this.getDebug());   break;  case Input.KEY_F12:   fullScreen = !fullScreen;//전체화면 플래그 토글   break;  } }  private void _removeAllChildren(){    //현재 Scene에 올려져 있는 모든 node를 해제한다  for(int i=0;i<node.size();i++){      GameObject temp = (GameObject)node.get(i);   temp.remove();  }  node.clear();    System.gc(); }
 //게임오브젝트 관리를 위한 기본 함수 public void addChild(GameObject child){    node.add(child); } public void removeChild(GameObject child){
  //삭제할 오브젝트를 리스트에 담는다  int idx = node.indexOf(child);
  if(idx!=-1 && deleteList.indexOf(child)==-1){//node에는 있고 deleteList에는 없으면      child.remove();   deleteList.add(child);     } }  //게임오브젝트 관리를 위한 추가 함수 public int getNumOfChildren(){
  //node에 직접 억세스할 수 없으므로 갯수를 알려주는 함수가 필요하다  return node.size(); } public GameObject getChildByTag(int tag){    //tag로 특정 오브젝트를 찾아내 돌려준다. tag가 중복된다면 제일 먼저 발견된 오브젝트가 리턴값이 된다.  GameObject ret = null;  for(int i=0;i<node.size();i++){   GameObject temp = (GameObject)node.get(i);   if( temp.tag == tag ){        ret = temp;    break;   }  }    return ret; } public GameObject getChildByName(String name){    //name으로 특정 오브젝트를 찾아내 돌려준다. name이 중복된다면 제일 먼저 발견된 오브젝트가 리턴값이 된다.  GameObject ret = null;  for(int i=0;i<node.size();i++){   GameObject temp = (GameObject)node.get(i);   if( temp.name.equals(name) ){        ret = temp;    break;   }  }    return ret; }  public Vector<GameObject> getChildrenByTag(int tag){
  //동일한 tag를 갖는 오브젝트 묶음(벡터)을 리턴한다  Vector<GameObject> ret = new Vector<GameObject>();     for(int i=0;i<node.size();i++){   GameObject temp = (GameObject)node.get(i);   if( temp.tag==tag ){        ret.add(temp);   }  }    return ret; } public Vector<GameObject> getChildrenByName(String name){
  //동일한 name을 갖는 오브젝트 묶음(벡터)을 리턴한다  Vector<GameObject> ret = new Vector<GameObject>();     for(int i=0;i<node.size();i++){   GameObject temp = (GameObject)node.get(i);   if( temp.name.equals(name) ){        ret.add(temp);   }  }    return ret; }   //기타 게임용 처리를 위한 추가 함수 static public Point getNextPos(float sx, float sy, float degree, float speed){
  //지정 좌표로부터 degree 각도로 speed 떨어진 위치의 점을 구한다
  Point dest = new Point(0, 0);  double rad = (degree-90)%360*Math.PI / 180;  dest.setX( (float)(sx + speed*Math.cos(rad)) );  dest.setY( (float)(sy + speed*Math.sin(rad)) );    return dest; } static public float getRange(float sx, float sy, float dx, float dy){    //두 개 좌표간의 거리를 구한다  return Math.abs((dy-sy)*(dy-sy)+(dx-sx)*(dx-sx)); } static public int getDegree(float sx, float sy, float dx, float dy){    //두 개 좌표간의 각도를 구한다  float vx=dx-sx;  float vy=dy-sy;  double rad=Math.atan2(vy,vx);  int degree=(int)(rad*57.3f)+90;  if(degree<0)   degree+=360;
  return degree;   }
 static public String numComma(String numStr){    //숫자 문자열에 , 넣기  DecimalFormat df = new DecimalFormat("#,###");  numStr = df.format(Integer.parseInt(numStr));
  return numStr; }  public void setPause(boolean isPause){    this.isPause = isPause; } public boolean isPaused(){    return this.isPause; } public void setDebug(boolean isDebug){    this.isDebug = isDebug; } public boolean getDebug(){    return this.isDebug; }  static public Shape getTransShape(Shape src, float centerX, float centerY, float scale, float degree){    Shape ret = src;    float px = - (centerX * (scale - 1));  float py = - (centerY * (scale - 1));
  ret = ret.transform(Transform.createScaleTransform(scale, scale));  ret = ret.transform(Transform.createTranslateTransform(px, py));  ret = ret.transform(Transform.createRotateTransform((float)Math.toRadians(degree), ret.getCenterX(), ret.getCenterY()));    return ret; }  static public Rectangle drawClipped(Graphics g, Image img, float posX, float posY, int width, int height, int wFrame, int vFrame){    //width, height : 1프레임의 너비와 높이  //wFrame : 프레임의 가로 순번 (0부터)  //vFrame : 프레임의 세로 순번 (0부터)    Rectangle rect = new Rectangle((int)posX-width/2, (int)posY-height/2, width,height);     Image _img = img.getSubImage(wFrame*width, vFrame*height, width, height);  _img.drawCentered(posX, posY);  //  g.setClip(rect);//  g.drawImage(img, posX  - wFrame*width - width/2,  posY - vFrame*height - height/2);//  g.setClip(0,0, 640,480);    return rect; }}
